use serde::{de::DeserializeOwned, Deserialize, Serialize};
use std::marker::PhantomData;

/// The default type to be used for `IdType` in the `Id<M, I>` where `I` is `IdType`
pub type DefaultType = String;

pub trait Generated: IdType {}

/// The IdType trait constraints.  When using your own type of the `id` field on a model, it must impl this trait
pub trait IdType: ToString + Serialize + DeserializeOwned + Clone + Send + Sync + PartialEq {}
impl<T: ToString + Serialize + DeserializeOwned + Clone + Send + Sync + PartialEq> IdType for T {}

/// The Id type for musty `Model`s
/// This is used by `Model` and `MongoModel`
/// This type is automatically generated when using the `#[model]` attribute macro
/// Any field named `id` in a Model will be automatically changed to this type
#[derive(Debug, Eq)]
pub struct Id<M, I: IdType = DefaultType> {
    /// The inner value of the id type, optional.  If none, serializing will skip this field.  If the type is ObjectId, this will be generated by the MongoDB server.
    pub(crate) inner: Option<I>,
    _marker: PhantomData<M>,
}

impl<M, I: IdType> PartialEq for Id<M, I> {
    fn eq(&self, other: &Self) -> bool {
        self.inner == other.inner
    }
}

impl<M, I: IdType> Id<M, I> {
    pub fn is_none(&self) -> bool {
        self.inner.is_none()
    }
}

impl<M, I: IdType> Clone for Id<M, I> {
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
            _marker: PhantomData,
        }
    }
}

impl<M, I: IdType> Default for Id<M, I> {
    fn default() -> Self {
        Self {
            inner: None,
            _marker: PhantomData,
        }
    }
}

impl<M, I: IdType> From<I> for Id<M, I> {
    fn from(id: I) -> Self {
        Self {
            inner: Some(id),
            _marker: PhantomData,
        }
    }
}

impl<M, I> Id<M, I>
where
    I: Generated,
{
    pub fn none() -> Self {
        return Self {
            inner: None,
            _marker: PhantomData,
        };
    }
}

impl<M, I: IdType> Serialize for Id<M, I> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.inner.serialize(serializer)
    }
}

impl<'de, M, I: IdType> Deserialize<'de> for Id<M, I> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = Deserialize::deserialize(deserializer)?;
        Ok(Self {
            inner: id,
            _marker: PhantomData,
        })
    }
}

#[cfg(feature = "bson")]
mod bson {
    use crate::error::MustyError;

    use super::*;
    use ::bson::{oid::ObjectId, Bson};

    impl Generated for ObjectId {}

    impl<M, I: IdType> TryFrom<Id<M, I>> for ObjectId {
        type Error = MustyError;

        fn try_from(id: Id<M, I>) -> Result<Self, Self::Error> {
            match id.inner {
                Some(id) => Ok(ObjectId::parse_str(&id.to_string())?),
                None => Err(crate::error::MustyError::Other(anyhow::anyhow!(
                    "Id is None"
                ))),
            }
        }
    }

    impl<M, I: IdType> TryFrom<&Id<M, I>> for ObjectId {
        type Error = MustyError;

        fn try_from(id: &Id<M, I>) -> Result<Self, Self::Error> {
            match &id.inner {
                Some(id) => Ok(ObjectId::parse_str(&id.to_string())?),
                None => Err(crate::error::MustyError::Other(anyhow::anyhow!(
                    "Id is None"
                ))),
            }
        }
    }

    impl<M, I: IdType + Into<Bson>> From<Id<M, I>> for Bson {
        fn from(id: Id<M, I>) -> Self {
            match id.inner {
                Some(id) => id.into(),
                None => Bson::Null,
            }
        }
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn serialize() {}

    #[test]
    fn deserialize() {}
}
